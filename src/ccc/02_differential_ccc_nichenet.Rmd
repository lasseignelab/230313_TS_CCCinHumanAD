---
title: "02_differential_ccc_nichenet"
author: "Tabea M. Soelter"
date: '2023-04-25'
output: html_document
---
**Differential Cell-Cell Communication Analysis using NicheNet**

__Goal__: For every dataset, perform differential NicheNet analyses between AD and CTRL to identify ligands, receptors, and potential downstream target genes between glia (Astrocytes, Oligodendrocytes, Microglia, and OPCs - senders) and Excitatory Neurons (receivers).
  
__Reproducibility__: 
* GitHub: lasseignelab/230313_TS_CCCinHumanAD
* Docker: tsoelter/rstudio_ccc_ad
    * Version: 1.0.0 
* HPC: Yes
  * Resources: long partition (150hrs), 6 CPUs, 65GB per CPU

#__Data__: EDIT THIS
* Name: vine_processed_seurat.rds, geo_processed_seurat.rds, vinecortex_processed_seurat.rds
* Location: /data/user/tsoelter/projects/230313_TS_CCCinHumanAD/data/
 
#__Analysis Plan__: EDIT THIS 
* Load necessary packages 
* Load data 
* Identify ligands using liana
* Load NicheNet's prior knowledge 
* Filter liana ligands using NicheNet's prior
* Save filtered ligands

__Analysis__:
# Load packages
```{r}
# Time tracking
ptm <- proc.time()

# set seed
set.seed(42)

# load packages
suppressPackageStartupMessages({
library(tidyverse)
library(nichenetr)
library(Seurat)
library(ggrepel)
library(cowplot)
library(RColorBrewer)
library(here)
library(styler)
library(lintr)
})

# load functions
source(here("src", "functions_CCCinAD_tms.R"))
```

# Load data
```{r}
# load all seurat objects
vine <- readRDS(here("data", "vine_processed_seurat.rds"))

geo <- readRDS(here("data", "geo_processed_seurat.rds"))

vine_cortex <- readRDS(here("data", "vinecortex_processed_seurat.rds"))

# create a list of all objects
object_list <- tibble::lst(vine, geo, vine_cortex)
```

# Load NicheNet prior
```{r}
# load the ligand target matrix
ligand_target_matrix <- readRDS(here("data",
                                     "ccc",
                                     "nichenet_prior",
                                     "ligand_target_matrix.rds"))

# load and filter the ligand receptor network as recommended by developers
lr_network <- readRDS(here(
  "data",
  "ccc",
  "nichenet_prior",
  "lr_network.rds")) %>%
  mutate(bonafide = !database %in% c("ppi_prediction", "ppi_prediction_go")) %>%
  dplyr::rename(ligand = from, receptor = to) %>%
  distinct(ligand, receptor, bonafide)

# set organism
organism <- "human"
```

# Differential NicheNet prep
* Each individual object and cluster within needs to be split by condition in order to apply NicheNet across conditions.
* I have added a metadata column with that information and made it the identity of the object.
* I am also plotting UMAPs of the split and saving them to results/intermediate_outputs/{object_name}/ccc/
* This is done for each object in the split_object_list
```{r warning=FALSE}
# Making cell-type aggregate object list and save celltype aggregate UMAPs
ca_object_list <- prep_nichenet(object_list,
                                file_path = "results/intermediate_outputs/")

# unlist and add objects to global environment for downstream use
list2env(ca_object_list, globalenv())
```

## Define niches
* Since I am interested in differences across conditions, my niches are AD and CTRL. 
* Within each niche, the sender and receiver cell types are also specified. 
```{r}
## Set niches
user_niches <- list("AD_niche"   = list("sender"   = c("Astrocytes_AD",
                                                       "Oligodendrocytes_AD",
                                                       "OPCs_AD",
                                                       "Microglia_AD"),
                                        "receiver" = c("Excitatory Neurons_AD")),
                    "CTRL_niche" = list("sender"   = c("Astrocytes_CTRL",
                                                       "Oligodendrocytes_CTRL",
                                                       "OPCs_CTRL",
                                                       "Microglia_CTRL"),
                                        "receiver" = c("Excitatory Neurons_CTRL")
                                        )
                    )
```

# TESTING ALL CODE HERE
```{r}
user_niches <- list("AD_niche"   = list("sender"   = c("Astrocytes_AD"),
                                        "receiver" = c("Excitatory Neurons_AD")),
                    "CTRL_niche" = list("sender"   = c("Astrocytes_CTRL"),
                                        "receiver" = c("Excitatory Neurons_CTRL")
                                        )
                    )



DE_sender_receiver <- diff_nichenet(object = vine, niches = user_niches, expression_pct = 0.10, lr_network = lr_network)

mock_spatial_data_list <- make_mock_spatial(include_spatial_info_sender = FALSE,
                                            include_spatial_info_receiver = FALSE,
                                            niches = user_niches)
list2env(mock_spatial_data_list, globalenv())

outs <- calculate_ligand_activity(vine,
                                  niches = user_niches,
                                  top_n_targets = 250,
                                  lfc_cutoff = 0.15)

list2env(outs, globalenv())

exprs_tbl_list <- calculate_scaled_gex(vine,
                                       lr_network = lr_network,
                                       ligand_activities_targets = ligand_activities_targets)

list2env(exprs_tbl_list, globalenv())

ligand_scaled_receptor_expression_fraction_df <- score_interactions(lr_network = lr_network,
                                                                    exprs_tbl_ligand = exprs_tbl_ligand,
                                                                    exprs_tbl_receptor = exprs_tbl_receptor,
                                                                    DE_sender_receiver = DE_sender_receiver_LIANA)

# these settings will favor DE l-r pairs compared to activity. Adapting these values can change what is favored. In-depth explanations of each factor can be found in the vignette for differential NicheNet. 
prioritizing_weights = c("scaled_ligand_score" = 5,
                         "scaled_ligand_expression_scaled" = 1,
                         "ligand_fraction" = 1,
                         "scaled_ligand_score_spatial" = 0, 
                         "scaled_receptor_score" = 0.5,
                         "scaled_receptor_expression_scaled" = 0.5,
                          "receptor_fraction" = 1, 
                         "ligand_scaled_receptor_expression_fraction" = 1,
                         "scaled_receptor_score_spatial" = 0,
                         "scaled_activity" = 0,
                         "scaled_activity_normalized" = 1,
                         "bona_fide" = 1)

# combine all outputs into one large list
output <- tibble::lst(DE_sender_receiver_LIANA,
                       ligand_scaled_receptor_expression_fraction_df,
                       sender_spatial_DE_processed,
                       receiver_spatial_DE_processed,
                       ligand_activities_targets,
                       DE_receiver_processed_targets,
                       exprs_tbl_ligand,
                       exprs_tbl_receptor,
                       exprs_tbl_target
                       )

# Prioritize interactions based on previously assigned weights 
prioritization_tables <- get_prioritization_tables(output, prioritizing_weights)


# save both output and prioritization tables




nichenet_wrapper <- function(object_list, user_niches, lr_network, prioritizing_weights, DE_sender_receiver) {
  for(name in names(object_list)) {
    # grab object --------------------
    seurat_obj <- get(name)
    print(paste0("Loaded ", name, " seurat object"))
    # DE analysis between niches --------------------
    DE_sender_receiver <- diff_nichenet(object = seurat_obj,
                                        niches = user_niches,
                                        expression_pct = 0.10,
                                        lr_network = lr_network)
    print("Differential gene expression analysis finished")
    # Filter ligands by LIANA ligands 
    DE_sender_receiver_LIANA <- subset(DE_sender_receiver, ligand %in% ligands)
    # Create mock spatial data --------------------
    mock_spatial_data_list <- make_mock_spatial(include_spatial_info_sender = FALSE,
                                                include_spatial_info_receiver = FALSE,
                                                niches = user_niches)
    print("Mock spatial data created")
    # unlist mock spatial data list to get objects needed --------------------
    list2env(mock_spatial_data_list, environment())
    # calculate ligand activity --------------------
    ligand_activity_list <- calculate_ligand_activity(seurat_obj,
                                                      niches = user_niches,
                                                      top_n_targets = 250,
                                                      lfc_cutoff = 0.15)
    print("Calculated ligand activity")
    # unlist ligand activity list list to get objects needed -------------------
    list2env(ligand_activity_list, environment())
    # calculate scaled expression --------------------
    exprs_tbl_list <- calculate_scaled_gex(seurat_obj,
                                           lr_network = lr_network,
                                           ligand_activities_targets = ligand_activities_targets)
    print("Calculated scaled expression")
    # unlist expression table list to get objects needed --------------------
    list2env(exprs_tbl_list, environment())
    # score interactions --------------------
    ligand_scaled_receptor_expression_fraction_df <-
      score_interactions(lr_network = lr_network,
                         exprs_tbl_ligand = exprs_tbl_ligand,
                         exprs_tbl_receptor = exprs_tbl_receptor,
                         DE_sender_receiver = DE_sender_receiver_LIANA)
    print("Scored interactions")
    # combine all outputs into one large list --------------------
    output <- tibble::lst(DE_sender_receiver_LIANA,
                          ligand_scaled_receptor_expression_fraction_df,
                          sender_spatial_DE_processed,
                          receiver_spatial_DE_processed,
                          ligand_activities_targets,
                          DE_receiver_processed_targets,
                          exprs_tbl_target
                          )
    print("Created output")
    # save output
    saveRDS(output, file = here(paste0("results/intermediate_outputs/",
                                name,
                                "/ccc/nichenet_output.rds"
                                )
            )
    )
    print("Saved output")
    # Prioritize interactions based on previously assigned weights ------------- 
    prioritization_tables <- get_prioritization_tables(output, 
                                                       prioritizing_weights
                                                       )
    print("Created prioritized output")
    # save prioritization tables
    saveRDS(prioritization_tables, file = here(paste0("results/intermediate_outputs/",
                                                      name,
                                                      "/ccc/nichenet_prioritization_tables.rds"
                                                      )
                                               )
            )
    print("Saved prioritized output")
  }
}


nichenet_wrapper(ca_object_list,
                 user_niches = user_niches,
                 lr_network = lr_network,
                 prioritizing_weights = prioritizing_weights,
                 DE_sender_receiver = DE_sender_receiver_LIANA)


```



I am cross-referencing ligands prioritized using LIANA and those from NicheNet. 
```{r}
DE_sender_receiver_LIANA <- subset(DE_sender_receiver, ligand %in% ligands)
# I removed all data points if the ligand column did not match the prioritized ligands from LIANA. I went from 51 072 to 1 902 interactions.  
```

# Adding mock spatial data (differential NicheNet will not run otherwise)
```{r}

```

# Calculate ligand activities and infer active ligand-target links 
```{r}
# recommended 10x min_lfc cutoff
lfc_cutoff <- 0.15
top_n_targets = 250
# using minimum lfc ensures that we identify ligand target interactions which have the strongest specificity. A high min lfc means that a ligand is more strongly expressed in the cell type of niche 1 compared to all cell types in niche 2

ligand_activities_targets <- calculate_ligand_activity(vine, niches = user_niches, top_n_targets = 250, lfc_cutoff = 0.15)
```

## Calculate the scaled expression of ligands, receptors, and targets across cell types of interest
- log expression values and expression fractions
```{r}


```

## Expression fraction and receptor 
Scoring the l-r interctions based on their expression strength of the receptor. 
```{r}
# don't forget that we use this: DE_sender_receiver <- DE_sender_receiver_LIANA


```

## Prioritization of ligand-receptor and ligand-target links
```{r}
# these settings will favor DE l-r pairs compared to activity. Adapting these values can change what is favored. In-depth explanations of each factor can be found in the vignette for differential NicheNet. 
prioritizing_weights = c("scaled_ligand_score" = 5,
                         "scaled_ligand_expression_scaled" = 1,
                         "ligand_fraction" = 1,
                         "scaled_ligand_score_spatial" = 0, 
                         "scaled_receptor_score" = 0.5,
                         "scaled_receptor_expression_scaled" = 0.5,
                          "receptor_fraction" = 1, 
                         "ligand_scaled_receptor_expression_fraction" = 1,
                         "scaled_receptor_score_spatial" = 0,
                         "scaled_activity" = 0,
                         "scaled_activity_normalized" = 1,
                         "bona_fide" = 1)

# combine all outputs into one large list
output <- tibble::lst(DE_sender_receiver_LIANA,
                       ligand_scaled_receptor_expression_fraction_df,
                       sender_spatial_DE_processed,
                       receiver_spatial_DE_processed,
                       ligand_activities_targets,
                       DE_receiver_processed_targets,
                       exprs_tbl_ligand,
                       exprs_tbl_receptor,
                       exprs_tbl_target
                       )

# Prioritize interactions based on previously assigned weights 
prioritization_tables <- get_prioritization_tables(output, prioritizing_weights)


# save both output and prioritization tables
```




# Session info
```{r}
sessionInfo() # see output below
```
R version 4.1.3 (2022-03-10)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Ubuntu 20.04.6 LTS

Matrix products: default
BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so

locale:
[1] C

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
 [1] SeuratObject_4.1.3 Seurat_4.3.0.9002  lintr_3.0.2        styler_1.9.1       here_1.0.1        
 [6] RColorBrewer_1.1-3 cowplot_1.1.1      ggrepel_0.9.3      nichenetr_1.1.1    lubridate_1.9.2   
[11] forcats_1.0.0      stringr_1.5.0      dplyr_1.1.2        purrr_1.0.1        readr_2.1.4       
[16] tidyr_1.3.0        tibble_3.2.1       ggplot2_3.4.2      tidyverse_2.0.0   

loaded via a namespace (and not attached):
  [1] utf8_1.2.3             spatstat.explore_3.1-0 reticulate_1.28        R.utils_2.12.2        
  [5] tidyselect_1.2.0       htmlwidgets_1.6.2      grid_4.1.3             Rtsne_0.16            
  [9] pROC_1.18.0            munsell_0.5.0          ragg_1.2.5             codetools_0.2-18      
 [13] ica_1.0-3              future_1.32.0          miniUI_0.1.1.1         withr_2.5.0           
 [17] spatstat.random_3.1-4  colorspace_2.1-0       progressr_0.13.0       knitr_1.42            
 [21] rstudioapi_0.14        stats4_4.1.3           ROCR_1.0-11            tensor_1.5            
 [25] listenv_0.9.0          labeling_0.4.2         polyclip_1.10-4        farver_2.1.1          
 [29] rprojroot_2.0.3        parallelly_1.35.0      vctrs_0.6.2            generics_0.1.3        
 [33] ipred_0.9-14           xfun_0.39              timechange_0.2.0       randomForest_4.7-1.1  
 [37] R6_2.5.1               doParallel_1.0.17      clue_0.3-64            rex_1.2.1             
 [41] bitops_1.0-7           spatstat.utils_3.0-2   promises_1.2.0.1       scales_1.2.1          
 [45] nnet_7.3-17            gtable_0.3.3           globals_0.16.2         processx_3.8.1        
 [49] goftest_1.2-3          timeDate_4022.108      rlang_1.1.0            cyclocomp_1.1.0       
 [53] systemfonts_1.0.4      GlobalOptions_0.1.2    splines_4.1.3          lazyeval_0.2.2        
 [57] ModelMetrics_1.2.2.2   spatstat.geom_3.1-0    checkmate_2.1.0        yaml_2.3.7            
 [61] reshape2_1.4.4         abind_1.4-5            backports_1.4.1        httpuv_1.6.9          
 [65] Hmisc_5.0-1            caret_6.0-94           DiagrammeR_1.0.9       tools_4.1.3           
 [69] lava_1.7.2.1           ellipsis_0.3.2         proxy_0.4-27           BiocGenerics_0.40.0   
 [73] ggridges_0.5.4         Rcpp_1.0.10            plyr_1.8.8             base64enc_0.1-3       
 [77] visNetwork_2.1.2       ps_1.7.5               rpart_4.1.16           deldir_1.0-6          
 [81] pbapply_1.7-0          GetoptLong_1.0.5       S4Vectors_0.32.4       zoo_1.8-12            
 [85] cluster_2.1.2          magrittr_2.0.3         data.table_1.14.8      scattermore_0.8       
 [89] circlize_0.4.15        lmtest_0.9-40          RANN_2.6.1             fitdistrplus_1.1-11   
 [93] R.cache_0.16.0         matrixStats_0.63.0     hms_1.1.3              patchwork_1.1.2       
 [97] mime_0.12              evaluate_0.20          xtable_1.8-4           IRanges_2.28.0        
[101] gridExtra_2.3          shape_1.4.6            compiler_4.1.3         KernSmooth_2.23-20    
[105] crayon_1.5.2           R.oo_1.25.0            htmltools_0.5.5        later_1.3.0           
[109] tzdb_0.3.0             Formula_1.2-5          ComplexHeatmap_2.10.0  MASS_7.3-55           
[113] Matrix_1.5-4           cli_3.6.1              R.methodsS3_1.8.2      parallel_4.1.3        
[117] gower_1.0.1            igraph_1.4.2           pkgconfig_2.0.3        foreign_0.8-82        
[121] sp_1.6-0               plotly_4.10.1          spatstat.sparse_3.0-1  recipes_1.0.6         
[125] xml2_1.3.3             foreach_1.5.2          hardhat_1.3.0          prodlim_2023.03.31    
[129] callr_3.7.3            digest_0.6.31          sctransform_0.3.5.9002 RcppAnnoy_0.0.20      
[133] spatstat.data_3.0-1    rmarkdown_2.21         leiden_0.4.3           htmlTable_2.4.1       
[137] uwot_0.1.14            shiny_1.7.4            rjson_0.2.21           lifecycle_1.0.3       
[141] nlme_3.1-155           jsonlite_1.8.4         desc_1.4.2             viridisLite_0.4.1     
[145] limma_3.50.3           fansi_1.0.4            pillar_1.9.0           lattice_0.20-45       
[149] fastmap_1.1.1          httr_1.4.5             survival_3.3-1         remotes_2.4.2         
[153] glue_1.6.2             fdrtool_1.2.17         png_0.1-8              iterators_1.0.14      
[157] class_7.3-20           stringi_1.7.12         textshaping_0.3.6      caTools_1.18.2        
[161] irlba_2.3.5.1          e1071_1.7-13           future.apply_1.10.0

# Time tracking
```{r}
fptm <- proc.time() - ptm

# convert to minutes
(fptm[3] / 60)

# Time elapsed:  minutes
# Hands-on time however is between  minutes!
```

# Reproducibility
```{r}
# styler
style_file(here(
  "src",
  "ccc",
  "02_differential_ccc_nichenet.Rmd"
))

# lintr
lint(filename = here(
  "src",
  "ccc",
  "02_differential_ccc_nichenet.Rmd"
))
```